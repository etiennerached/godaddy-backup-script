#!/bin/bash
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Initial Developer of the Original Code is
# Etienne Rached
# https://github.com/etiennerached
# http://www.tech-and-dev.com/2013/10/backup-godaddy-files-and-databases.html
#
# Portions created by the Initial Developer are Copyright (C) 2013
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
# Andrew Parlane
# https://github.com/andrewparlane
# ***** END LICENSE BLOCK *****

################# Script Execution ###################

###!!! Edit at your own risk !!!###

#Store Current Date
Date=`date '+%Y-%m-%d_%H-%M-%S'`

#The first argument is the backup directory to use.
#This is not relative to ${backupDirectory}.
#It can be relative to the current directory or absolute
#For examlpe:
#  ./restore.sh /abc/def/2017-12-13_16-42
#  backup_script/restore.sh backups/2017-12-13_16-42
#It must contains:
#  One config.sh
#  One .sql or .sql.gz file per database entry in config.sh
#  One .cnf for each dbName in config.sh
#  One archive starting with files_ with the extension .tar, .tar.gz, .zip
#Specifically this directory should have been generated by the backup.sh script
if [ $# -eq 0 ]
then
    echo "Required argument for backup file path" >&2
    exit -1
fi
if [ ! -d $1 ]
then
    echo "$1 does not exist" >&2
    exit -1
fi

#check for config.sh
if [ ! -e "$1/config.sh" ]
then
    echo "config.sh does not exist in this backup dir" >&2
    exit -1
fi
# get our config
. $1/config.sh

#Check there is exactly 1 .sql or .sql.gz file for each $dbName
#When we find the file we populate dbBackup[] to use later
#And check for the .cnf
dbBackup=""
for i in ${!dbName[@]}
do
    if [ -z ${dbName[$i]} ]
    then
        echo "dbName[$i] is empty, ignoring db" &>2
    else
        #How many .sql[.gz] files exist for this dbName
        backupExists=0
        for f in $1/${dbName[$i]}_*;
        do
            if [ -e $f ]
            then
                dbBackup[$i]=$f
                backupExists+=1
            fi
        done

        #Check that there's at least one
        if [ ${backupExists} -eq 0 ]
        then
            echo "No backup exists for db ${dbName[$i]}" >&2
            exit -1
        fi

        #Check there's not more than one
        if [ ! ${backupExists} -eq 1 ]
        then
            echo "More than one backup exists for ${dbName[$i]}" >&2
            exit -1
        fi

        #Check for the .cnf
        if [ ! -e "$1/${dbCnf[$i]}" ]
        then
            echo "$1/${dbCnf[$i]} does not exist" >&2
            exit -1
        fi
    fi
done

#Now check there is one and only one files_... .tar, .tar.gz, .zip file
backupExists=0
filesBackup=""
for f in $1/files_*;
do
    if [ -e $f ]
    then
        filesBackup=$f
        backupExists+=1
    fi
done

#Check that there's at least one
if [ ${backupExists} -eq 0 ]
then
    echo "No backup exists for files" >&2
    exit -1
fi

#Check there's not more than one
if [ ! ${backupExists} -eq 1 ]
then
    echo "More than one backup exists for files" >&2
    exit -1
fi

##### Restore Databases #####

echo "Restoring databases"

for i in ${!dbName[@]}
do
    if [ ! -z ${dbName[$i]} ]
    then
        while true; do
        echo "Attempting to restore database ${dbName[$i]}"
        read -p "Do you wish to use the backedup credentials file ${dbCnf[$i]}? [y/n] " yn
            case $yn in
                [Yy]* )
                    # use the credential file from the backup directory
                    mysqlCmd="mysql --defaults-extra-file=$1/$(basename ${dbCnf[$i]}) ${dbName[$i]}";
                    break;;
                [Nn]* )
                    # enter the credentials manually
                    # first the host name (defaults to localhost)
                    read -p "Enter hostname [localhost]: " hostname
                    if [ -z ${hostname} ]
                    then
                        hostname="localhost"
                    fi
                    # then the user name
                    read -p "Enter username: " username
                    mysqlCmd="mysql -h ${hostname} -u ${username} -p ${dbName[$i]}";
                    break;;
                * ) echo "Please answer yes or no.";;
            esac
        done

        #gzipped?
        if [[ "${dbBackup[$i]}" == *.gz ]]
        then
            gunzip -c ${dbBackup[$i]} | ${mysqlCmd}
        else
            cat ${dbBackup[$i]} | ${mysqlCmd}
        fi

        #Check the result
        if [ ! $? -eq 0 ]
        then
            echo "Failed to restore databasa ${dbName[$i]}" >&2
            exit -1
        else
            echo "Database ${dbName[$i]} restored OK"
        fi
    fi
done

echo "Restored all databases"

##### END OF Restore Databases #####

##### restore Files #####

echo "Restoring files"

#We first extract everything to a temporary directory
tmpRestoreDir="$HOME/tmp_restore_dir_$Date"
if [ -d ${tmpRestoreDir} ]
then
    echo "${tmpRestoreDir} already exists. Please delete it and try again" >&2
    exit -1
fi

#Create it
mkdir -p ${tmpRestoreDir}

#Check it's there now
if [ ! -d ${tmpRestoreDir} ]
then
    echo "Failed to create ${tmpRestoreDir}" >&2
    exit -1
fi

#Any existing files that would be overwritten get saved here
tmpReplacedOnDir="$HOME/tmp_replaced_on_$Date"
if [ -d ${tmpReplacedOnDir} ]
then
    echo "${tmpReplacedOnDir} already exists. Please delete it and try again" >&2
    exit -1
fi

#Create it
mkdir -p ${tmpReplacedOnDir}

#Check it's there now
if [ ! -d ${tmpReplacedOnDir} ]
then
    echo "Failed to create ${tmpReplacedOnDir}" >&2
    exit -1
fi

echo "Extracting ${filesBackup} to ${tmpRestoreDir} this may take a while"

#Zip
if [[ "${filesBackup}" == *.zip ]]
then
    unzip -q ${filesBackup} -d ${tmpRestoreDir}
fi

#Tar
if [[ "${filesBackup}" == *.tar ]]
then
    tar -xf ${filesBackup} -C ${tmpRestoreDir}
fi

#Tar GZip
if [[ "${filesBackup}" == *.tar.gz ]]
then
    tar -zxf ${filesBackup} -C ${tmpRestoreDir}
fi

#Check the result
if [ ! $? -eq 0 ]
then
    echo "Failed to extract ${filesBackup}" >&2
    #Delete the empty tmp dir
    exit -1
else
    echo "Files extracted OK"
fi

#Check the expected files exist in this backup
for i in ${!filesPath[@]}
do
    #Does this file path exist in ${tmpRestoreDir}
    if [ ! -e "${tmpRestoreDir}/${filesPath[$i]}" ]
    then
        echo "Expected file / directory ${filesPath[$i]} doesn't exist in ${tmpRestoreDir}" >&2
        #Continue anyway
    else
        #yep, exists
        #Check if this file / dir exists in $HOME
        if [ -e "$HOME/${filesPath[$i]}" ]
        then
            #yep, exists there too
            #move this to the tmpReplacedOnDir
            #so we can replace it with the restored version
            mkdir -p "${tmpReplacedOnDir}/$(dirname ${filesPath[$i]})"
            mv "$HOME/${filesPath[$i]}" "${tmpReplacedOnDir}/$(dirname ${filesPath[$i]})/"
        fi

        #Move the restroed file to $HOME
        mv "${tmpRestoreDir}/${filesPath[$i]}" "$HOME/${filesPath[$i]}"
    fi
done

echo "Files restored OK"

##### END OF Restore Files #####

echo "Backup $1 restored"
echo "Old files stored in ${tmpReplacedOnDir}, delete when ready"

################# END OF Script Execution ###################
